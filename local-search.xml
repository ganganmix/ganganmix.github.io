<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>编程思想:进程，线程和协程</title>
    <link href="/2023/02/11/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/"/>
    <url>/2023/02/11/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="导论——高性能的程序，异步，多进程和多线程的秘密"><a href="#导论——高性能的程序，异步，多进程和多线程的秘密" class="headerlink" title="导论——高性能的程序，异步，多进程和多线程的秘密"></a>导论——高性能的程序，异步，多进程和多线程的秘密</h1><ol><li>如何提高性能<ul><li>进程(process)</li><li>线程(thread)</li><li>协程(coroutine)</li></ul></li><li>如何实现和使用<ul><li>async:最常用的提高性能手段</li><li>socket:进程间的通信</li></ul></li></ol><hr><h2 id="如何提高性能"><a href="#如何提高性能" class="headerlink" title="如何提高性能"></a>如何提高性能</h2><p>​    计算机的性能，其实和我们干体力劳动很像，好比是我们要搬东西。对于计算机的性能，我们需要有个标准来衡量。这个标准中主要有两个指标。第一个是<strong>响应时间（Response time）</strong>或者叫<strong>执行时间（Execution time）</strong>。想要提升响应时间这个性能指标，你可以理解为让计算机“跑得更快”</p><p>​    在程序的执行中，通过某些手段把responsetime进行降低，就是最基础的性能提升，现在一般是通过**异步(async)*<em>的方式进行处理的，当然也有不支持异步的少数派<del>(java!说的就是你😡😡😡</del>当然只是原生java不支持，可以通过引入</em>Java.util.concurrent*包来实现，它提供了许多的类和接口(interface)</p><hr><ul><li><h3 id="进行-process"><a href="#进行-process" class="headerlink" title="进行(process)"></a>进行(process)</h3></li></ul><p>​    来一段官方的:</p><blockquote><p>进程是<strong>正在运行的程序实体</strong>，并且包括这个运行的程序中占据的所有系统资源，比如说CPU（ 寄存器 ），IO, 内存 ，网络资源等</p></blockquote><p>说实话，官方的定义都是这样晦涩，当然一些blog可能还会细分，比如：</p><blockquote><p>狭义定义：进程就是一段程序的执行过程。<br>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p></blockquote><p>这些都是对的，都是可能理解是有偏差或者对我来说不太好理解😋👈🤣</p><p>​    在我看来，进程是电脑的和电脑的CPU直接挂钩的一种<strong>硬件资源</strong>。现在来说，最差的电脑也要有9个进程资源。</p><p>在电脑的使用中，一个应用程序使用到CPU的资源，也就是它创造了一个属于它的进程。当然也就是说在物理上，这些线程是相互隔离的。如果要相互通信，可以使用socket实现(很早的标准方法</p><p>当然，一个计算机的进程资源是有限的，所以它会有进程池的机制，这和eventloop有异曲同工之妙。</p><ul><li><h3 id="线程-thread"><a href="#线程-thread" class="headerlink" title="线程(thread)"></a>线程(thread)</h3></li></ul><p>一台电脑的服务绝对是比process的数量要多得多，而一个进程的数据处理能力也比一个简单的程序要强大，所以进程会分出许多线程(thread)来处理这个程序的其他必要的程序</p>]]></content>
    
    
    
    <tags>
      
      <tag>编程思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IT行业的宏观经济学作业</title>
    <link href="/2023/02/01/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    <url>/2023/02/01/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="近年来IT行业势微的经济学原理"><a href="#近年来IT行业势微的经济学原理" class="headerlink" title="近年来IT行业势微的经济学原理"></a>近年来IT行业势微的经济学原理</h1><ol><li>问题的现象，背景与研究<ul><li>为什么IT行业的势微</li><li>产生的背景</li><li>问题的研究</li></ul></li><li>研究的结论与局限性<ul><li>结论</li><li>局限性</li></ul></li></ol><h2 id="现象，背景与讲究"><a href="#现象，背景与讲究" class="headerlink" title="现象，背景与讲究"></a>现象，背景与讲究</h2><h3 id="为什么IT行业的势微"><a href="#为什么IT行业的势微" class="headerlink" title="为什么IT行业的势微"></a>为什么IT行业的势微</h3><p>​    最近一段时间，互联网上一直都有“资本寒冬”，经济下滑，大公司裁员的消息，那么现实到底如何呢。</p><p>​    这是有关部门调查的各行的经济占比图</p><p>​    <img src="\img\task\行业经济占比图.jpg" alt="行业经济占比图" style="zoom:60%;" /></p><p>​    可以看到，对比与传统的房地产，金融或者商贸业等，还是比较占优势，也可以看出目前我国的IT行业还在成长期，数字化和自动化技术还处于成长期，未来应该由比较好的发展光景。但是目前，中国的 IT 行业正面临多重因素的影响，包括市场竞争加剧、技术快速发展、投资环境恶劣等。此外，由于国内经济增长放缓和贸易紧张局势，以及全球经济不确定性加剧，中国 IT 行业也面临着诸多挑战。因此，在未来几年内，中国 IT 行业也可能面临一定的困难和挑战。</p><p>​    但是，越是经济形式不明朗，通过技术研发构建核心竞争力的需求就越发迫切。企业通过高新技术降低成本、提质增效，才是过冬的最佳选择。而且，从目前来看，各个行业目前都必须紧跟IT行业的步伐才能保证在现代化的发展潮流中不掉队，诸如云计算、大数据、物联网、人工智能等近年来耳熟能详的高端技术也慢慢落地，进入我们的日常生活中了。在国家层面上，也一直大力发展高新技术，所以，至少几十年内，IT行业的主导地位还是不可撼动的。</p><h3 id="产生的背景"><a href="#产生的背景" class="headerlink" title="产生的背景"></a>产生的背景</h3><p>​    近些年来，虽然我国的计算机科学在蓬勃发展，但是一般都体现在高新产业，而且现在的市场竞争日益激烈，各大公司都在争夺有限的已经开发了的市场份额。技术的快速发展，新技术的不断涌现，使得许多公司难以保持竞争力。由疫情带来的经济增长放缓，国内经济增长放缓，市场需求下降，对 IT 行业的需求也受到影响。国际上的贸易紧张局势，由于全球贸易紧张局势，中国 IT 行业也受到了一些影响。这些因素的共同作用，导致了IT行业看起来势微</p><h3 id="问题的研究"><a href="#问题的研究" class="headerlink" title="问题的研究"></a>问题的研究</h3><p>​    采取的是在宏观经济学研究中常用的<strong>技术分析法</strong>进行研究的，比如技术趋势分析，分析 IT 行业的核心技术，了解技术发展趋势和未来发展方向。进行市场需求分析，了解市场对 IT 技术的需求，并评估技术的市场潜力。作技术创新分析，评估 IT 行业中的技术创新，了解行业的技术创新动态。调查技术竞争分析，分析 IT 行业的竞争情况，了解行业中的技术差距和竞争力。技术风险分析，评估 IT 行业的技术风险，并对风险进行评估和管理。通过对 IT 行业技术的全面分析，可以了解行业的发展状况，为决策提供支持。</p><hr><h2 id="研究的结论与局限性"><a href="#研究的结论与局限性" class="headerlink" title="研究的结论与局限性"></a>研究的结论与局限性</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>​    2021年7月，Facebook的老板扎克伯格提出了Metaverse战略，计划在五年内把Facebook转型为一家元宇宙公司，宣布投资100亿美元用于研发元宇宙技术，并在10月28日将Facebook更名为Meta。可以说是2021年科技界轰动性的大新闻。资本的嗅觉往往是最灵敏的，欧美和国内股市的巨量资金纷纷涌向与“元宇宙”相关的公司。因此，“元宇宙”一度成为资本市场最火热的概念宠儿。但在此之前，很多人都还不知道什么是“元宇宙”，甚至到了现在，依然有很多人没听过“元宇宙”这个概念!这也为中国IT行业未来的发展带来光亮，中国 IT 行业正处于快速发展阶段，技术发展趋势较为稳定，市场需求旺盛。</p><p>​    我国面对的国际电子信息产业发展的大环境 与20世纪70~80年代有很大的不同，因而加大了产业结构调整和升级的难度。首先，从经济全球化的角度看，这种环境的变化主要体现在：第一，全球经济正处在资源积聚时代（雷达2003年），即产业积聚化、簇群化、国际化，其中包括国际产业纵向关联，横向关联、区位优势形成的产业融合或渗透，以及产业之间建立战略联盟的步伐加快。在这种环境下，IT产业表现的十分突出。IT 行业技术的创新动态较强，但存在部分技术尚未被广泛应用的情况。</p><p>​    我国IT行业经历了近三十年的发展，已经初步具备规模与影响力，初步形成了完整的产业链，其庞大的产业规模与良好的经济效益为带动我国经济的进步做出了巨大的贡献，为我国严峻的就业形势起到了巨大的支撑作用，其意义非同凡响。但IT行业的特点就是技术性强，专业化水平高，而我国虽然拥有庞大的行业规模，但我国IT企业却大多处在组装加工环节，技术水平低，严重缺乏自主的核心技术。同时核心技术作为在华IT企业的命脉，其技术保护性很强。就要在加快外资企业的技术溢出和同时有效的吸收技术溢出。要完善产业结构，强化产业薄弱环节等都是我国IT行业需要研究和解决的问题。</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>​    任何研究都存在局限性，调查也不例外。一些可能的调查局限性。在样本偏差方面，调查样本不能代表整个 IT 行业，结果可能受到样本的偏差影响。调查方法局限性，使用的调查方法有可能不能全面反映 IT 行业的实际情况。时间有所偏差，调查数据可能随着时间的推移而失效，对于 IT 行业的未来发展趋势不具有预测性。资料有局限性，调查所依据的资料有可能不全面，缺乏关键信息。</p><p>​    除此之外， IT 行业发展也存在一些局限性。技术具有风险，IT 行业存在一定的技术风险，如技术失效、安全性问题等，需要加强风险管理。竞争力度加剧， IT 行业竞争激烈，竞争对手不断壮大，需要不断加强技术创新能力。技术更新周期缩短，IT 行业的技术更新周期不断缩短，需要加强技术更新速度。当然也有疫情冲击等等因数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>task</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程思想:鸭子类型</title>
    <link href="/2023/02/01/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/02/01/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="导论——“数据的虚假之天”"><a href="#导论——“数据的虚假之天”" class="headerlink" title="导论——“数据的虚假之天”"></a>导论——“数据的虚假之天”</h1><ol><li>数据类型<ul><li>鸭子类型(duck typing)</li><li>实现举例</li></ul></li><li>数据的本质<ul><li>object组成的world</li></ul></li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>数据类型</strong>是指一种定义在编程语言中的类别，用于表示<strong>变量</strong>、<strong>常量</strong>或<strong>表达式的值</strong>的类型。每种数据类型都有不同的<strong>内存空间限制</strong>，以及支持不同的操作。常见的数据类型包括<strong>整数、浮点数、字符串、布尔值</strong>等。数据类型的选择有助于编译器更好地验证程序的语法和语义正确性，并且可以避免在运行时出现的错误。</p><ul><li><h3 id="鸭子类型-Duck-Typing"><a href="#鸭子类型-Duck-Typing" class="headerlink" title="鸭子类型(Duck Typing)"></a>鸭子类型(Duck Typing)</h3></li></ul><blockquote><p>编程语言是哲学与科学碰撞的产物，有许多基于习惯的设计都有它背后的哲学(わくわく😋)</p><p>听说duck typing是漂亮国🗽的诗人的诗作：</p><blockquote><p><strong>When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.</strong> ——james</p></blockquote><p>大概意思是，当我看到鸟方方面面都像一只鸭子，那么它就是鸭子~~(这不是扯，这叫哲学♂)</p><p>当然也还有很多有意思的思想，比如在错误处理方面的LBYL和EAFP：</p><blockquote><p><strong>Look before you leap.</strong></p></blockquote><blockquote><p><strong>Easier to Ask for Forgiveness than Permission.</strong></p></blockquote><p>就不赘述哒🤗</p></blockquote><ul><li><h3 id="实现举例"><a href="#实现举例" class="headerlink" title="实现举例"></a>实现举例</h3></li></ul><p>这种思想的体现一般是不分编程语言的，在实现某些功能后就可以使用(比如<strong>oop</strong>)</p><p>例えば：</p><p>在python里，有一种数据类型叫<strong>Dict</strong>，它是一种<strong>无序的，可变的数据集合类型，数据是以key:value的形式存储的</strong></p><blockquote><p><strong>我们可以用dict[key]取出它的value值</strong></p></blockquote><p>当你用python里的_<em>dir</em>_()查看类型实现时，会发现它实现了许多方法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">d = <span class="hljs-built_in">dict</span>()<br><span class="hljs-built_in">print</span>(d.__dir__())<br><span class="hljs-comment"># [&#x27;__new__&#x27;, &#x27;__repr__&#x27;, &#x27;__hash__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__lt__&#x27;, &#x27;__le__&#x27;, &#x27;__eq__&#x27;, &#x27;__ne__&#x27;, &#x27;__gt__&#x27;, &#x27;__ge__&#x27;, &#x27;__iter__&#x27;, &#x27;__init__&#x27;, &#x27;__or__&#x27;, &#x27;__ror__&#x27;, &#x27;__ior__&#x27;, &#x27;__len__&#x27;, &#x27;__getitem__&#x27;, &#x27;__setitem__&#x27;, &#x27;__delitem__&#x27;, &#x27;__contains__&#x27;, &#x27;__sizeof__&#x27;, &#x27;get&#x27;, &#x27;setdefault&#x27;, &#x27;pop&#x27;, &#x27;popitem&#x27;, &#x27;keys&#x27;, &#x27;items&#x27;, &#x27;values&#x27;, &#x27;update&#x27;, &#x27;fromkeys&#x27;, &#x27;clear&#x27;, &#x27;copy&#x27;, &#x27;__reversed__&#x27;, &#x27;__class_getitem__&#x27;, &#x27;__doc__&#x27;, &#x27;__str__&#x27;, &#x27;__setattr__&#x27;, &#x27;__delattr__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__reduce__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__format__&#x27;, &#x27;__dir__&#x27;, &#x27;__class__&#x27;]</span><br></code></pre></td></tr></table></figure><p>当然，这些都是c实现的，我们暂时不管，我们看到一个显眼的**_<em>dict</em>_**的魔术方法，用法是:</p><blockquote><p>以key:value的形式，存放属性：输入值</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">My_Dict</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        self.args = args<br>        self.kwargs = kwargs<br>        <br>md = My_Dict(<span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>)<br><span class="hljs-built_in">print</span>(md.__dict__)<br><span class="hljs-comment"># 返回字典，它是以类属性为dict，类内容是&#123;&#x27;args&#x27;: (&#x27;value1&#x27;, &#x27;value2&#x27;), &#x27;kwargs&#x27;: &#123;&#125;&#125;</span><br><span class="hljs-built_in">print</span>(md.__dict__[<span class="hljs-string">&#x27;args&#x27;</span>])<br><span class="hljs-comment"># 返回*args的数据:(&#x27;value1&#x27;,&#x27;value2&#x27;)</span><br></code></pre></td></tr></table></figure><p>所以，我们就可以把它看作dict[key]取属性的字典</p><blockquote><p><strong>看山便是山，看水亦是水</strong></p><p><strong>能吃就是饭，能烧就是柴</strong></p></blockquote><p>这使我们更关注对象的行为，而不是类型</p><hr><p>在java中也有体现，也就是接口(<strong>interface</strong>)实现，通过implements对interface进行实现，就可以得到所用方法实现的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">duck</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">quacks</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">yellow</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">duck</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quacks</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;yellow duck&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">black</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">duck</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quacks</span><span class="hljs-params">()</span>&#123;<br>        System.out.pirntln(<span class="hljs-string">&quot;black duck&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">cry</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">yellow</span>();<br>        y.quacks();<br>        <br>        <span class="hljs-type">cry</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">black</span>();<br>        b.quacks();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>提供接口(interface)可以让实现它的class得到它定义的操作，也就是是只要实现了duck这个接口，他就在**<del>鸭子叫</del>**</p><hr><h2 id="数据的本质"><a href="#数据的本质" class="headerlink" title="数据的本质"></a>数据的本质</h2><p>数据的本质其实就是一个个对象，而对象又是实现了某些方法的实例</p><p>比如包括：</p><blockquote><p>基本数据类型：’byte’,’short’,’int’,’long’,’float’,’double’,’boolean’和’char’</p><p>引用数据类型：class，implement，array等</p></blockquote><p>当然概念在各大编程语言通用，但是基本类型可能有偏差</p><ul><li><h3 id="object组成的world"><a href="#object组成的world" class="headerlink" title="object组成的world"></a>object组成的world</h3></li></ul><blockquote><p>duck类型就是在说，任何数据类型都是假的，都只是实现某些api的类的实例，也就是对象(object)</p><p>这种实现，在py里通过魔术方法，在java或者go中，通过接口(implement)，结构体(struct)</p></blockquote><p>结论：</p><p>**<del>数据类型根本就不存在(癫狂</del>**🥵👈🤣</p>]]></content>
    
    
    
    <tags>
      
      <tag>编程思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-二，网络的协议</title>
    <link href="/2023/01/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%8C%EF%BC%8C%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/01/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%8C%EF%BC%8C%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<ol><li>由协议组成的world<ul><li>iso七层模型</li><li>简化版四层概念模型</li></ul></li><li>网络的流程<ul><li>如何通信</li><li>如何访问</li><li>如何创造</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络:一，计算机网络的组成</title>
    <link href="/2023/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%80%EF%BC%8C%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%84%E6%88%90/"/>
    <url>/2023/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%80%EF%BC%8C%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="导论——范围网络"><a href="#导论——范围网络" class="headerlink" title="导论——范围网络"></a>导论——范围网络</h1><ol><li>由网络组成的world<ul><li>局域网(LAN)的概念与组成</li><li>广域网(WAN)的概念与组成</li><li>互联网(INTERNET)的概念与组成</li></ul></li></ol><h2 id="1-由网络组成的world"><a href="#1-由网络组成的world" class="headerlink" title="1. 由网络组成的world"></a>1. 由网络组成的world</h2><blockquote><h3 id="局域网-LAN-的概念与组成"><a href="#局域网-LAN-的概念与组成" class="headerlink" title="局域网(LAN)的概念与组成"></a>局域网(LAN)的概念与组成</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>局域网(LAN)<strong>是:局部地区形成的一个</strong>区域网络</strong>，其自身相对其他网络传输速度更快，性能更稳定，框架更简易，而且这是封闭性的。但是局域网会有一个与外界网络的<strong>接入点</strong>（<em>比如路由器的WAN口</em>，接入的设备(路由器)主要负责中继无线计算机(网络设备)之间的数据包传输和分配，还负责中继无线计算机(网络设备)和internet之间的数据包）来作为交换机等处理数据。无线局域网(WLAN)有一个通信标准——<strong>IEEE 802.11</strong>,<strong>Wi-Fi</strong>就是对这一标准最好的实现。<del>要长脑子了😋</del></p><p>（<font color="red"><strong>路由器和交换机并不是一个概念，路由器在网络层，路由器会分配子网的IP地址并根据IP地址寻址，还可以处理TCP/IP协议，交换机不可以。交换机在中继层，它根据MAC地址寻址，用来分配网络数据，也就是要用LAN口物理链接</strong></font>）<strong>但是现在家用路由器一般都集成了交换机的功能</strong></p><img src="\img\计算机网络-iso模型和计算机的理解\局域网原理.jpg" alt="局域网原理" style="zoom:67%;" /><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>局域网的基本组成是硬件系统和软件系统(<del>网上查的，俺真厉害😊👈🤣</del>)</p><blockquote><p>硬件系统</p><p><strong>网络服务器、网络工作站、链接设备(网卡)以及传输介质和其他互连设备</strong></p><p><em>网络服务器</em>：种类很多，分为文件服务器，打印服务器，硬件服务器等等。当然这些也都是非必要的。</p><p><em>网络工作站</em>：也就是客户端(client)，一般就是电脑计算机哒💻。可以通过软件等访问网络服务器进行操作。</p><p><em>连接设备</em>：即是网卡，简称”NIC“，它是链接计算机与网络的硬件的设备(种类非常多😵)。</p><p>传输介质：就像空气是声音传播的介质一样，上述的设备通信和数据传输都需要介质，一般的传输介质是<strong>双绞线，同轴电缆，光纤等</strong>。</p><p>其他…🤗🤗🤗</p><p>软件系统</p><p><strong>主要包括网络操作系统，网络数据库管理系统，网络应用软件</strong></p><p><em>网络操作系统</em>：说是一种能代替操作系统的软件程序，借用网络互相传递数据和各种信息，分为服务端(server)和客户端(client)。</p><p><em>网络数据库管理系统</em>：是一种能将内存里的数据存入硬盘做数据持久化的软件，简称<strong>DBMS</strong>。他的目地是管理和控制数据库，以保证数据库的安全性和完整性。</p><p><em>网络应用软件</em>：就是日常使用的app捏😋😋😋</p></blockquote><img src="\img\计算机网络-iso模型和计算机的理解\标准局域网.jpg" alt="标准局域网" style="zoom:67%;" /><p><del>在个人设备localhost(127.0.0.1)网段下的进程不被外界打扰，也像是一个小型的LAN</del></p></blockquote><hr><blockquote><h4 id="广域网-WAN-的概念与组成"><a href="#广域网-WAN-的概念与组成" class="headerlink" title="广域网(WAN)的概念与组成"></a>广域网(WAN)的概念与组成</h4><p><strong>概念</strong></p><p>**广域网(WAN)**是一种大型的，地域型的计算机网络集合，但其范围可以超过城市，国家乃至全球。所以，广域网其实一种相对概念。(<s><del>局域网上的局域网🤗</del></s>)</p><p><strong>组成</strong></p><p>一般由<strong>主机(资源子网)和通信子网</strong>组成</p><blockquote><p>*主机(资源子网)*：由上网的所有<strong>主机</strong>及其<strong>外部设备</strong>组成😵‍💫😵‍💫😵‍💫。</p><p><em>通信子网</em>：由一些专用的通信处理器(即<strong>节点交换机</strong>)及其运行的<strong>软件，集中器</strong>等设备和链接这些节点的<strong>通信链路</strong>组成。</p></blockquote><img src="\img\计算机网络-iso模型和计算机的理解\广域网.jpg" alt="广域网" style="zoom:67%;" /></blockquote><hr><blockquote><h4 id="互联网-INTERNET-的概念与组成"><a href="#互联网-INTERNET-的概念与组成" class="headerlink" title="互联网(INTERNET)的概念与组成"></a>互联网(INTERNET)的概念与组成</h4><p><strong>概念</strong></p><p>**互联网(INTERNET)**是由局域网，广域网等组成的一个最大网络，它是一种宽泛的概念型的存在。</p><p><strong>组成</strong></p><p>按照工作方式分为<strong>边缘部分和核心部分</strong></p><blockquote><p><em>边缘部分</em>：就是连接在互联网上的所有主机(又称**”端系统”**)，是用户直接使用的。💻📱</p><p><em>核心部分</em>：是由大量网络和连接这些网络的路由器组成，其为边缘部分提供服务。</p></blockquote><img src="\img\计算机网络-iso模型和计算机的理解\INTERNET.png" alt="INTERNET" style="zoom:67%;" /></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QQbot第一弹:nonebot的原理————go-cqhttp的数据包</title>
    <link href="/2023/01/11/QQbot%E7%AC%AC%E4%B8%80%E5%BC%B9-nonebot%E7%9A%84%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94gocqhttp%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/"/>
    <url>/2023/01/11/QQbot%E7%AC%AC%E4%B8%80%E5%BC%B9-nonebot%E7%9A%84%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94gocqhttp%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><ol><li>go-cqhttp的链接<ul><li>项目的概述</li></ul></li><li>go-cqhttp与nonebot的通信连接<ul><li>连接方式</li><li>socket服务器的接收实例</li><li>websocket服务器的接收实例</li></ul></li></ol><blockquote><h3 id="go-cqhttp的链接"><a href="#go-cqhttp的链接" class="headerlink" title="go-cqhttp的链接"></a>go-cqhttp的链接</h3><ul><li><h4 id="项目的概述"><a href="#项目的概述" class="headerlink" title="项目的概述"></a>项目的概述</h4></li></ul><p><b><a href="https://docs.go-cqhttp.org/">go-cqhttp</a></b>,基于 Mirai 以及 MiraiGo 的 OneBot Golang 原生实现的项目，主力是go语言编写(<font color=red><s>俺也不会捏</s></font>🤗)</p></blockquote><p>(反正就是ddl很nb哒←<font size="2" color="cyan">明明什么都不知道的小白</font>👈😂)</p><blockquote><p>它的兼容性:</p><div id="interface"><font size="4" color="black"><b>接口</b></font></div><ul><li><p>http api</p></li><li><p>反向http post</p></li><li><p>正向websocket</p></li><li><p>反向websocket</p></li></ul><p><font size="4" color="black"><b>性能</b></font></p><ul><li>在关闭数据库的情况下, 加载 25 个好友 128 个群运行 24 小时后内存使用为 10MB 左右. 开启数据库后内存使用将根据消息量增加 10-20MB , 如果系统内存小于 128M 建议关闭数据库使用。<br><a href="https://docs.go-cqhttp.org/">go-cqhttp 帮助中心</a></li></ul><p><img src="https://user-images.githubusercontent.com/25968335/120111974-8abef880-c139-11eb-99cd-fa928348b198.png" alt="go-cqhttp"></p></blockquote><hr><h2 id="go-cqhttp与nonebot的通信连接"><a href="#go-cqhttp与nonebot的通信连接" class="headerlink" title="go-cqhttp与nonebot的通信连接"></a>go-cqhttp与nonebot的通信连接</h2><ul><li><h4 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h4></li></ul><p>go-cqhttp与nonebot的链接可以选择gc提供的<a href="#interface">接口</a>的几种方式</p><img src="\img\QQbot第一弹-nonebot的原理——gocqhttp的数据包\interface.png" alt="interface" style="zoom:60%;" /><p>我想要反向websocket进行获取，就是我作websoocket的服务器，让go-cqhttp作客户端给我们发送消息<font color="red"><s>(其实是因为不是很了解这些接口)</s></font>，我好菜😭😭😭</p><img src="\img\QQbot第一弹-nonebot的原理——gocqhttp的数据包\choose.png" alt="choose" style="zoom:60%;" /><p>选择3，反向websocket，这样也可以看看go-cqhttp的到底发的什么玩意😋😋😋</p><ul><li><h4 id="socket服务器的简单实例"><a href="#socket服务器的简单实例" class="headerlink" title="socket服务器的简单实例"></a>socket服务器的简单实例</h4></li></ul><p>我们先打开go-cqhttp并登录</p><img src="\img\QQbot第一弹-nonebot的原理——gocqhttp的数据包\gocq_login.png" alt="gocq_login" style="zoom:50%;" /><p>下面是一个简单的socket服务器，那么为什么要用socket而不是websocket捏，因为<s>我搞错了&gt; 😋</s>，因为我也想知道如果协议不对，go-cqhttp会发个什么东西过来😊😊😊</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br>server = socket.socket(socket.AF_INET, socket.sock_STREAM)<br>server.bind((<span class="hljs-string">&quot;&quot;</span>, post)) <span class="hljs-comment"># 端口号</span><br>server.listen(<span class="hljs-number">126</span>) <span class="hljs-comment"># 设置监听，参数为最大队列数</span><br>new_socket, path = server.sccept()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    data = new_socket.recv()<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) != <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(data.decode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br>    <span class="hljs-keyword">else</span>:<br>        new_socket.close()<br>        <span class="hljs-keyword">break</span><br>server.close()<br></code></pre></td></tr></table></figure><p>↑(<font color="blue"><s>什么垃圾code</s></font>😭😭😭)</p><p>运行之后,出现一次心跳包后就close了，说明go-cqhttp客户端发现协议不对，主动断开链接了:</p><img src="\img\QQbot第一弹-nonebot的原理——gocqhttp的数据包\gocq_warning.png" alt="gocq_warning" style="zoom:60%;" /><p>显示<font color="red"><b>unexpected EOF</b></font>,至于是什么意思。。。（自行baidu😊👈😂）</p><p>我们看看python的socket服务端，它为我们提供了更详细的内容:</p><img src="\img\QQbot第一弹-nonebot的原理——gocqhttp的数据包\gocq_py.png" alt="gocq_py" style="zoom:60%;" /><p>发现<font color="red"><b>Connection: Upgrade</b></font>和<font color="red"><b>Upgrade: websocket</b></font>，意思就是说要更换成<b>websocket</b></p><p><b>好！那就换吧</b>🤗🤗🤗</p><hr><ul><li><h4 id="websocket服务器的接收实例"><a href="#websocket服务器的接收实例" class="headerlink" title="websocket服务器的接收实例"></a>websocket服务器的接收实例</h4></li></ul><p>我使用python写了一个简单的异步websocket服务器，用json来解析json数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> websocket<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">data</span>(<span class="hljs-params">websocket, path</span>): <span class="hljs-comment">#创建一个异步回调函数data，传入两个参数，websocket套接字，path数据协议</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> message <span class="hljs-keyword">in</span> websocket: <span class="hljs-comment"># 迭代出websocket里面的数据</span><br>        j = json.loads(message)<br>        <span class="hljs-built_in">print</span>(j)<br>asyncio.get_event_loop().run_until_compete(websocket.server(data, <span class="hljs-string">&quot;localhost&quot;</span>, post)) <span class="hljs-comment"># 传入post，host，和</span><br>asyncio.get_event_loop().run_forever()<br></code></pre></td></tr></table></figure><blockquote><p>我们通过异步的方式接收代码，得到的数据可以分为三种</p><blockquote><p>连接成功的提示消息：(成功时会发出消息”<strong>meta_event_type”为”lifecycle</strong>“)</p><img src="\img\QQbot第一弹-nonebot的原理——gocqhttp的数据包\success.png" alt="success" style="zoom:60%;" /><p>与客户端的<u>心跳</u><s>❤️</s>包:  (心跳包的”<strong>post_type”是”meta_event</strong>“)</p><img src="\img\QQbot第一弹-nonebot的原理——gocqhttp的数据包\mete_event.png" alt="mete_event" style="zoom:60%;" /><p>对应的消息数据：(news_event的**”post_type”是”message”**)</p><img src="\img\QQbot第一弹-nonebot的原理——gocqhttp的数据包\message_data.png" alt="message_data" style="zoom:60%;" /></blockquote><p>这其中的就包括相应的<b>消息数据</b>，<b>time</b>等等👈😊，也就是有了nb的第一版(bushi</p></blockquote><p>最后，挂一张老婆  <a href="https://github.com/Ikaros-521"><strong>Love丶伊卡洛斯</strong></a>(java大佬，<a href="https://space.bilibili.com/3709626">b站up</a>，<s><font color="red"><b>大厂员工(不干了)</b></font></s>)：</p><p><img src="https://avatars.githubusercontent.com/u/40910637?v=4" alt="**Love丶伊卡洛斯**"></p>]]></content>
    
    
    
    <tags>
      
      <tag>nonebot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇:hello world!</title>
    <link href="/2023/01/11/%E7%AC%AC%E4%B8%80%E7%AF%87-hello-world/"/>
    <url>/2023/01/11/%E7%AC%AC%E4%B8%80%E7%AF%87-hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇写的目的其实就是说明，俺要开始写了，所以是hallo-world"><a href="#第一篇写的目的其实就是说明，俺要开始写了，所以是hallo-world" class="headerlink" title="第一篇写的目的其实就是说明，俺要开始写了，所以是hallo world!"></a>第一篇写的目的其实就是说明，俺要开始写了，所以是<font color="red">hallo world</font>!</h1><blockquote><p>我以后会用test这个tag来收集md编写技巧或者一些什么东西,也可以不用看吧🤗🤗🤗</p></blockquote><h2 id="留下点东西吧"><a href="#留下点东西吧" class="headerlink" title="留下点东西吧"></a>留下点东西吧</h2><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello world!&quot;</span>)<br></code></pre></td></tr></table></figure><p>javascript</p></blockquote><blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello world!&quot;</span>)<br></code></pre></td></tr></table></figure><p>python</p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">helloworld</span>&#123;  <span class="hljs-comment">//public类名要与java文件名一致,也就是文件的出口</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(string[] args)</span>&#123;<br>       System.out.print(<span class="hljs-string">&quot;hello world!&quot;</span>); <span class="hljs-comment">//有System.out当然有System.in哒😊</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>java</p></blockquote><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   fmt.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>go</p></blockquote><blockquote><blockquote><p>最后,贴一张我的偶像<a href="https://github.com/djkcyl">A60</a>🥵🥵🥵,是我暂时的信仰捏😋😋😋</p></blockquote><p><img src="https://avatars.githubusercontent.com/u/59153990?v=4" alt="A60"></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
