<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>tesk:日语27课，课文</title>
    <link href="/2023/02/20/tesk-%E6%97%A5%E8%AF%AD27%E8%AF%BE%EF%BC%8C%E8%AF%BE%E6%96%87/"/>
    <url>/2023/02/20/tesk-%E6%97%A5%E8%AF%AD27%E8%AF%BE%EF%BC%8C%E8%AF%BE%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="イベント当日-eventとうじつ"><a href="#イベント当日-eventとうじつ" class="headerlink" title="イベント当日(eventとうじつ)"></a>イベント当日(eventとうじつ)</h1><ol><li>会话<ul><li>会話の中で、出現だ単語の用法</li><li>会話の大体の意味</li></ul></li><li>注意点<ul><li>日本人の節日</li></ul></li></ol><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p><font color="red">アナウンサ-</font>:日本ではこれから<font color="red">桜の季節</font>を迎えますが，ここ上海も春を迎えています。現在，酒造会社の竜虎酒造が主催する「日本酒『金星」に合う創作中華料理」というコンテストが行われています。会場には桜の木が飾られ，日本的な<font color="red">雰囲気</font>です。それでは，竜虎酒造の担当者である佐藤さんにお話を伺います。たいへん盛況ですね。</p><details><summary>翻译</summary>    <pre>记者：在日本，樱花季节即将到来，而上海这里也迎来了春天。    目前，由酒造公司龙虎酒造主办的“配合日本酒‘金星’的创意中华料理”比赛正在举行。    会场装饰着樱花树，有着日本的氛围。接下来我们请到龙虎酒造的负责人佐藤先生来讲话。场面非常热闹呢。</pre></details><blockquote><p>アナウンサ-：【英】(announcer)播音员，主持人，记者<br>桜の季節:  日本的樱花一般在3月下旬到4月中旬开放，被称为樱花季<br>(n2)雰囲気(ふんいき)：气氛，<del>空气</del>，氛围感<br><font color="yellow">雰囲気を読む</font> 读懂气氛，这个人比较懂事</p></blockquote><hr><p>佐藤：わたしたちも正直、コンテストに<font color="red">これほど</font>の応募があるとは思っていませんでした。</p><details><summary>翻译</summary>    <pre>佐藤：我们也说实话，没有想到竞赛会有这么多的参赛申请。</pre></details><blockquote><p>これほど：これ 这样 ，ほど 高程度</p></blockquote><hr><p>アナウンサー：中国国内で「金星」が販売されて、<font color="red">ちょうど</font>1年と聞きましたが、売れ行きのほうはいかがですか。</p><details><summary>翻译</summary>    <pre>记者：听说中国国内已经销售了“金星”，已经过去了一年时间，请问销售情况如何呢？</pre></details><blockquote><p>ちょうど：正好，恰好，刚好</p><p>この問題はちょうど私が専門の分野です     这个问题正是我的专业领域。</p></blockquote><hr><p>佐藤：中国国内では、これまでに50万本の売り上げがありました。当初は、北京、上海などの都市部が中心でしたが、今では、各地の大型デパート、スーパーマーケットなどにも出荷しています。</p><details><summary>翻译</summary>        <pre>佐藤：在中国国内，已经销售了50万个产品。最初，主要集中在北京、上海等城市，但现在已经开始向各地的大型百货商店、超市等销售。</pre></details><hr><p>アナウンサー：「金星」が<font color="red">これだけ</font>中国の市場に受け入れられた理由は何だとお考えですか。</p><details><summary>翻译</summary>        <pre>记者：您认为“金星”之所以在中国市场如此受欢迎的原因是什么？</pre></details><blockquote><p>これだけ和これほど的区别</p><p>“これだけ”表示“这么多”、“只有这么多”、“正好这么多”的意思。常常表示数量、大小、程度等。</p><p>これほど”表示“这么”、“如此”、“这般”的意思。可以表示程度、规模等。它的语气比“これだけ”更加强烈，表示数量或者程度超出了预期或者想象之外。</p></blockquote><hr><p>佐藤：日本人の感覚でものを見るのではなく、中国人の感覚になってものを見ようと考えたことが、ポイントではないかと思います。</p><details>    <summary>翻译</summary>    <pre>佐藤：我认为重要的一点是，不是按照日本人的感觉去看待事物，而是设身处地地换位思考，按照中国人的感觉去看待事物</pre></details><blockquote><p>对于在中国市场的成功，他认为自己能够成功的一个原因就是，他们不是按照日本人的观念和感觉去设计和推销这个产品，而是考虑了中国消费者的观念和感觉，对产品进行了调整。因此，佐藤认为这一点是非常关键的。</p></blockquote><hr><p>アナウンサー：中国人の感覚になるというと?</p><details><summary>翻译</summary>        <pre>记者：按照中国人的感觉是什么意思？</pre></details><hr><p>佐藤：幸いなことに、今回、<font color="red">優れた中国人スタッフとチームを組むことができました</font>。彼らの意見を積極的に受け入れることで、<font color="red">中国人から見た日本酒のイメージを大切にできました。</font>今回の成功は、彼らの協力なしにはありえなかったと思います。</p><details><summary>翻译</summary>        <pre>佐藤：幸运的是，这次我们能够与出色的中国员工和团队合作。积极接受他们的意见，我们能够重视中国人对日本酒的印象。我认为，如果没有他们的合作，这次的成功是不可能实现的</pre></details><blockquote><p>这句话的主语優れた中国人スタッフとチーム 表示出色的中国员工和团队</p><p>谓语 “組むことができました” 表示能够组成一个团队。</p><p>“ことができる” 表示能够、可以的意思。</p><p>最后一部分是 “中国人から見た日本酒のイメージを大切にできました”，意思是通过理解中国人对日本酒的看法，更好地展现日本酒的特点和魅力，从而在中国市场上取得成功。</p></blockquote><hr><p>アナウンサー：そうですか。たしか、この会場にも来られていると聞きましたが。</p><details>    <summary>翻译</summary>        <pre>记者：这样吗，所以，听说他们也来到了这个会场呢。</pre></details><hr><p>佐藤：ええ。（<strong>引导旁边的李秀丽站到前面</strong>）広告を担当してくれたJC企画の李秀麗さんです。</p><details><summary>翻译</summary>    <pre>佐藤：是的。（引导旁边的李秀丽站到前面）这是为我们的广告负责的JC企划的李秀丽女士。</pre></details><hr><p>アナウンサー：では、李秀麗さんにお話をお聞きしたいと思います。</p><p>李さん、最初の質問ですが…。（<strong>就在把话筒对准李秀丽的瞬间，李秀丽摇摇晃晃地晕倒了。</strong>）</p><details><summary>翻译</summary>    <pre>记者：：那么，接下来请李秀丽女士发表一下看法。（正当把话筒对准李秀丽的时候，李秀丽晕倒了。）</pre></details><hr><p>アナウンサー：キャー!どうしましょう。</p><details><summary>翻译</summary>    <pre>记者：呀！怎么办啊。</pre></details><hr><p>佐藤：（<strong>抱起李秀丽</strong>）すごい熱だ。だれか!救急車!救急車を呼んでください!</p><details><summary>翻译</summary>        <pre>佐藤：（扶起李秀丽）她发烧很厉害。有人能帮忙吗？叫救护车！快叫救护车！</pre></details><blockquote><p>すごい熱だ：这里的すごい表示程度，相似的有</p><ul><li>ひどい: 非常不好，剧烈，恶劣</li><li>とても：非常，非常に，很，极其；</li><li>とんでもなく：极其，异常；</li><li>めっちゃ：非常，非常に，超级，极其；</li><li>すごく：非常，很，极其；</li><li>ものすごく：非常，特别，极其。</li></ul></blockquote><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li><h3 id="日本人の節日-せちにち"><a href="#日本人の節日-せちにち" class="headerlink" title="日本人の節日(せちにち)"></a>日本人の節日(せちにち)</h3></li></ul><p><strong>1.元旦</strong>　公历1月1日)</p><p><strong>2.成人节</strong>(一月第二周的星期一)</p><p><strong>3.春分</strong>(公历3月21日左右)</p><p><strong>4.昭和の日</strong>(公历4月29日)</p><p><strong>5.宪法纪念日</strong>(公历5月3日)</p><p><strong>6.绿の日</strong>(公历5月4日)</p><p><strong>7.儿童节</strong>(公历5月5日)</p><p><strong>8.海节</strong>(七月第三个星期一)</p><p><strong>9.山节</strong>(公历8月11日)</p><p><strong>10.敬老节</strong>(九月第三个星期一)</p><p><strong>11.秋分</strong>(公历9月23日左右)</p><p><strong>12.体育节</strong>(十月第二个星期一)</p><p><strong>13.文化节</strong>(公历11月3日)</p><p><strong>14.劳动[感恩节]</strong>(公历11月23日)</p><p>而且，日本人一般会提前公布一年的休息时间也就是假期</p><p>比如2023今年的：</p><table><thead><tr><th>名称</th><th>日付</th><th>備考</th></tr></thead><tbody><tr><td>元日</td><td>1月1日</td><td></td></tr><tr><td>休日</td><td>1月2日</td><td>祝日法第3条第2項による休日</td></tr><tr><td>成人の日</td><td>1月9日</td><td></td></tr><tr><td>建国記念の日</td><td>2月11日</td><td></td></tr><tr><td>天皇誕生日</td><td>2月23日</td><td></td></tr><tr><td>春分の日</td><td>3月21日</td><td></td></tr><tr><td>昭和の日</td><td>4月29日</td><td></td></tr><tr><td>憲法記念日</td><td>5月3日</td><td></td></tr><tr><td>みどりの日</td><td>5月4日</td><td></td></tr><tr><td>こどもの日</td><td>5月5日</td><td></td></tr><tr><td>海の日</td><td>7月17日</td><td></td></tr><tr><td>山の日</td><td>8月11日</td><td></td></tr><tr><td>敬老の日</td><td>9月18日</td><td></td></tr><tr><td>秋分の日</td><td>9月23日</td><td></td></tr><tr><td>スポーツの日</td><td>10月9日</td><td></td></tr><tr><td>文化の日</td><td>11月3日</td><td></td></tr><tr><td>勤労感謝の日</td><td>11月23日</td><td></td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>task</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>py基础:abc</title>
    <link href="/2023/02/15/py%E5%9F%BA%E7%A1%80-abc/"/>
    <url>/2023/02/15/py%E5%9F%BA%E7%A1%80-abc/</url>
    
    <content type="html"><![CDATA[<h1 style="text-align:center">鸽🤗</h1><h1 id="导论——“俺只会‘纸上谈兵’，怎么搞开发捏”"><a href="#导论——“俺只会‘纸上谈兵’，怎么搞开发捏”" class="headerlink" title="导论——“俺只会‘纸上谈兵’，怎么搞开发捏”"></a>导论——“俺只会‘纸上谈兵’，怎么搞开发捏”</h1><ol><li>abc是啥(Abstract Base Class)<ul><li>基类</li><li>抽象基类</li></ul></li><li>如何实现<ul><li>实例</li><li>理解实现</li></ul></li><li>抽象基类的意义<ul><li>设计</li><li>控制</li></ul></li></ol><hr><h2 id="abc是啥-what-is-ABC"><a href="#abc是啥-what-is-ABC" class="headerlink" title="abc是啥(what is ABC"></a>abc是啥(what is ABC</h2><p>​    abc全称<strong>Abstract Base Class</strong>，是oop编程思想的精华(个人觉得)。abstract base class也就是abc，它，，，</p><blockquote><p>就是定义了纯虚数(原自c++的概念)成员函数的类(虚类)，纯虚数一般只提供接口(interface)而没有具体的实现(但是也可以有)，一般有它的子类进行重写。抽象类不能被实例化，但虚函数可以调用(子类对它重写时会使用到相应的代码)，通常作为基类(base class)来被子类继承，子类重写虚函数，实现具体接口。其中，虚函数必须重写，一般method可以选择重写。</p></blockquote><ul><li><h3 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h3><p>说到基类(base class)就不得不提一下元类(metaclass)</p><blockquote><p>元类(metaclass)，本质也是一个类，但和普通类的用法不同，它可以对类内部的定义（包括类属性和类方法）进行动态的修改。可以这么说，使用元类的主要目的就是为了实现在创建类时，能够动态地改变类中定义的属性或者方法。</p></blockquote></li></ul><p>​    也就是说，元类也是作类设计时候不可缺少的的一个方法，但是比较与基类又有不同</p><blockquote><p>基类(base class)，是继承类的类，它继承自一个类，也将要被某个类继承而实现某些功能。它是在元类之上的一个概念，它可以更硬性的规定一个类实现的method，这是为了实现规范化，是很严格的实现要求。</p></blockquote><p>所以：</p><blockquote><p><strong>class—<del>inherit</del>—&gt;base class —<del>inherit</del>—&gt;metaclass</strong></p><p>(👈这个🤔也许🤗大概😋应该😡算了</p></blockquote><p>​    而其实，万物基于type，type是所有class的metaclass。当然，一般会有一个objectclass来被继承，而objectclass就是继承自typeclass。<del>所以objectclass是万物之父，而typeclass是万类之母。</del></p><ul><li><h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3></li></ul><p>​    抽象基类(abstract base class)</p><p>​    抽象基类是一个oop里的重要概念，它也是一种class，但是因为有一些黑魔法的影响，他不能被实例成obj，而是作为父类成为模板去指定子类实现一些抽象方法(abstract method)，这些方法是必须实现的，它有些部分是写死在cpython源代码里的(其他语言俺就不太知道哒)，非常<del>good</del>(😡)。它的核心是ABCMeta，之后的抽象子类都继承自他，但是abstract base class是不能被当作metaclass的。当然，它的源码也有高天解释过了，咱就讲一下理解。</p><hr><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><ul><li><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABCMeta, abstractmethod<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base_class</span>(metaclass=ABCMeta):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">ad</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;base_class:ad&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">d</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;base_class:d&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">subclass_1</span>(<span class="hljs-title class_ inherited__">base_class</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">ad</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;subclass_1:ad&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">subclass_2</span>(<span class="hljs-title class_ inherited__">base_class</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">d</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;subclass:d&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">subclass_3</span>(<span class="hljs-title class_ inherited__">base_class</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">ad</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;subclass_3:ad&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">d</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;subclass_3:d&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    bc = base_class() <span class="hljs-comment"># TypeError: Can&#x27;t instantiate abstract class base_class with abstract method ad</span><br>    sc1 = subclass_1()<br>    sc1.ad() <span class="hljs-comment"># subclass_1:ad</span><br>    sc1.d() <span class="hljs-comment"># base_class:d</span><br>    sc2 = subclass_2() <span class="hljs-comment"># TypeError: Can&#x27;t instantiate abstract class subclass_2 with abstract method ad</span><br>    sc2 = subclass_3()<br>    sc3.ad() <span class="hljs-comment"># subclass_3:ad</span><br>    sc3.d() <span class="hljs-comment"># subclass_3:d</span><br><br></code></pre></td></tr></table></figure><hr><ul><li><h2 id="理解实现"><a href="#理解实现" class="headerlink" title="理解实现"></a>理解实现</h2>这个功能的实现肯定依赖了许多黑魔法，但是我只能理解我看得懂得部分。。。其中叫@abstractmethodc的decorete长这样。被他装饰的method必须有一个abstractclass，不然是没有效果的。</li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">abstractmethod</span>(<span class="hljs-params">funcobj</span>):<br>    funcobj.__isabstractmethod__ = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">return</span> funcobj<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">abstractclassmethod</span>(<span class="hljs-title class_ inherited__">classmethod</span>):<br>        __isabstractmethod__ = <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">callable</span></span>):<br>        <span class="hljs-built_in">callable</span>.__isabstractmethod__ = <span class="hljs-literal">True</span><br>        <span class="hljs-built_in">super</span>().__init__(<span class="hljs-built_in">callable</span>)<br></code></pre></td></tr></table></figure><p>  ​    这两个是代码检查功能实现的核心，是decorate，通过的funcobj或者classmethod来判断里面的__isabstractmethod__是否为true，进而判断它是否为一个abstractmethod，所以abc的核心就是这个__abstractmethod__。当然，俺是看不懂其中的黑魔法的，所以这只是俺的理解。</p><p>  ​    那么，这个__abstractmethod__是怎么来的捏，要知道普通的class是没有这个属性的，，，</p><p>  这就是ABCMeta的效果，继承它的类会被动一些<del>手脚</del>。。。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">from</span> _abc <span class="hljs-keyword">import</span> (get_cache_token, _abc_init, _abc_register,<br>                      _abc_instancecheck, _abc_subclasscheck, _get_dump,<br>                      _reset_registry, _reset_caches)<br><span class="hljs-keyword">except</span> ImportError:<br>    <span class="hljs-keyword">from</span> _py_abc <span class="hljs-keyword">import</span> ABCMeta, get_cache_token<br>    ABCMeta.__module__ = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABCMeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">mcls, name, bases, namespace, **kwargs</span>):<br>            cls = <span class="hljs-built_in">super</span>().__new__(mcls, name, bases, namespace, **kwargs)<br>            _abc_init(cls)<br>            <span class="hljs-keyword">return</span> cls<br></code></pre></td></tr></table></figure><p>重点在__new__这个magic，它在调用type的__new__创造cls之后，又有一步_abc_init()的操作，那么这个函数干了什么捏，，，</p><p>咱也不知道，因为它是有黑魔法的😋😋😋</p><p>所以咱如果突发奇想，要自己实现abc的话，，，其实也简单，</p><p>在类中聚合一个属性，</p>]]></content>
    
    
    
    <tags>
      
      <tag>py基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git的使用:一般的操作</title>
    <link href="/2023/02/13/git%E7%9A%84%E4%BD%BF%E7%94%A8-%E4%B8%80%E8%88%AC%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/02/13/git%E7%9A%84%E4%BD%BF%E7%94%A8-%E4%B8%80%E8%88%AC%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="导论——“开源的窗户”"><a href="#导论——“开源的窗户”" class="headerlink" title="导论——“开源的窗户”"></a>导论——“开源的窗户”</h1><ol><li><p>git的初使用</p><ul><li>git平台</li><li>git的结构</li><li>git config</li></ul></li><li><p>基本操作</p><ul><li><p>git init</p></li><li><p>git clone</p></li><li><p>git add</p></li><li><p>git status</p></li><li><p>git diff</p></li><li><p>git commit以及其规范</p></li><li><p>git log (查看提交)</p></li><li><p>git remote</p></li><li><p>git pull</p></li><li><p>git push origin master</p></li></ul></li></ol><h2 id="git的初使用"><a href="#git的初使用" class="headerlink" title="git的初使用"></a>git的初使用</h2><ul><li><h3 id="git平台"><a href="#git平台" class="headerlink" title="git平台"></a>git平台</h3></li></ul><p>​    在互联网上有许多可以用git提交code的平台，只是github是最出名的而已，但是一些国外的平台一般都要会一点点魔法(具体推荐v2ray🤔</p><p>另外，如果自己有一台服务器，只需要让安装git，选择在一个空目录下建立git仓库，并且使它和github或是其他平台同步，然后在本地remote它，然后push推送:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git remote add my_server username@server:/var/project.git<br></code></pre></td></tr></table></figure><blockquote><p><strong>my_server</strong>是后面server地址的别名，和正常使用remote一样</p><p><strong>username</strong>是服务器用户名</p><p><strong>server</strong>是服务器的ip或域名</p><p><strong>/var/project.git</strong>是git仓库所在的目录</p></blockquote><p>​    之后，只需要正常的push操作就能把code提交到server上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git push my_server master<br></code></pre></td></tr></table></figure><ul><li><h3 id="git的结构"><a href="#git的结构" class="headerlink" title="git的结构"></a>git的结构</h3></li></ul><p>​    在本地一般分为三个区域，**工作区(workspace)，暂存区(staging)，本地库(local)**。</p><blockquote><p>**工作区(workspace):**就是project所在的文件夹</p><p>**暂存区(staging):**指.git目录下的index文件</p><p>**本地库(local):**相对remote的存在，一般commit后就会生成一系列文件，它们共同组成本地库</p></blockquote><p>这三个区域通过git命令进行交互，因为是local操作，所以不需要网络。然后通过remote加入origin(远程链接)就可以使用进行push。</p><img src="C:\Users\true\Desktop\blog\index\themes\hexo-theme-fluid\source\img\git基础\git交互.jpg" alt="git交互" style="zoom:67%;" /><ul><li><h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3></li></ul><p>​    git的config有三层:<strong>系统，全局，本地</strong>，git在使用时要读取这些文件，它们的全重依次增大，高权重配置会覆盖低权重配置。</p><p>其中<strong>user.name</strong>和<strong>user.email</strong>是必须的配置，git平台会根据这两样的hash判断是否为当前账户的推送。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global user.name &#123;user.name&#125;<br>git config --global user.email &#123;user.email&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><details>  <summary>git init (创建一个空git仓库，本质是一个。git文件，其中包含objects等，同时会创建一个master分支HEAD的初始。)</summary>  <pre>  -q(--quiet) 仅打印error和warning  --bare 创建纯仓库  --object-format={format} 指定存储对象的hash。sha1是默认值  -b --initial-branch={branch-name} 指定初始分支的名称  </pre>  </details>  </li><li><details>      <summary>git clone(将仓库当前分支的code克隆到本地，并为每个分支建立跟踪分支)</summary>      <pre>      --no-tags 不克隆标签      -b (--breanch) 将新创建的HEAD指向相应的分支      </pre>  </details>  </li><li><details>      <summary>git add (将文件提交到暂存区(staging))</summary>      <pre>      -n (--dry-run)  展示文件暂存区      -v (-verbose) 冗余模式      -f (--force) 强行添加忽略文件      -u (--update) 将修改文更新到暂存区中      </pre>  </details></li><li><details>  <summary>git status(比较commit提交的本地库(local)和add后的暂存区(staging))</summary>      <pre>      -s --short 简化输出      -b --branch 显示分支和跟踪消息      </pre>  </details>  </li><li><details>      <summary>git diff(显示暂存区以及暂存区和工作区的修改)</summary>        <pre>      -s       </pre>  </details></li></ul><h4 id="commit规范-git-cz"><a href="#commit规范-git-cz" class="headerlink" title="commit规范(git cz"></a>commit规范(git cz</h4> <details>        <summary>git commit(提交)</summary>     <pre>     <pre><code class="hljs"> &lt;/pre&gt;</code></pre></details></details>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程思想:进程，线程和协程</title>
    <link href="/2023/02/11/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/"/>
    <url>/2023/02/11/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="导论——高性能的程序，异步，多进程和多线程的秘密"><a href="#导论——高性能的程序，异步，多进程和多线程的秘密" class="headerlink" title="导论——高性能的程序，异步，多进程和多线程的秘密"></a>导论——高性能的程序，异步，多进程和多线程的秘密</h1><ol><li>如何提高性能<ul><li>进程(process)</li><li>线程(thread)</li><li>协程(coroutine)</li></ul></li><li>总结<ul><li>小刻都能听得懂的总结</li><li>老婆婆🥵🥵🥵</li></ul></li></ol><hr><h2 id="如何提高性能"><a href="#如何提高性能" class="headerlink" title="如何提高性能"></a>如何提高性能</h2><p>​    计算机的性能，其实和我们干体力劳动很像，好比是我们要搬东西。对于计算机的性能，我们需要有个标准来衡量。这个标准中主要有两个指标。第一个是<strong>响应时间（Response time）</strong>或者叫<strong>执行时间（Execution time）</strong>。想要提升响应时间这个性能指标，你可以理解为让计算机“跑得更快”</p><p>​    在程序的执行中，通过某些手段把responsetime进行降低，就是最基础的性能提升，现在一般是通过**异步(async)*<em>的方式进行处理的，当然也有不支持异步的少数派<del>(java!说的就是你😡😡😡</del>当然只是原生java不支持，可以通过引入</em>Java.util.concurrent*包来实现，它提供了许多的类和接口(interface)</p><hr><ul><li><h3 id="进行-process"><a href="#进行-process" class="headerlink" title="进行(process)"></a>进行(process)</h3></li></ul><p>​    来一段官方的:</p><blockquote><p>进程是<strong>正在运行的程序实体</strong>，并且包括这个运行的程序中占据的所有系统资源，比如说CPU（ 寄存器 ），IO, 内存 ，网络资源等</p></blockquote><p>说实话，官方的定义都是这样晦涩，当然一些blog可能还会细分，比如：</p><blockquote><p>狭义定义：进程就是一段程序的执行过程。<br>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p></blockquote><p>这些都是对的，都是可能理解是有偏差或者对我来说不太好理解😋👈🤣</p><p>​    在我看来，进程是电脑的和电脑的CPU直接挂钩的一种<strong>硬件资源</strong>。现在来说，最差的电脑也要有9个进程资源。</p><p>在电脑的使用中，一个应用程序使用到CPU的资源，也就是它创造了一个属于它的进程。当然也就是说在物理上，这些线程是相互隔离的。如果要相互通信，可以使用socket实现(很早的标准方法</p><p>​    当然，一个计算机的进程资源是有限的，所以它会有<strong>进程池</strong>的机制(其实是一种编程设计)</p><p>但是如果程序数量还是超出进程的承受范围，则会出现调度问题，这也是操作系统的核心功能之一，功能是管理进程运行状态，分配CPU的时间片，从而会有一些调度优先级的东西。当然，一般这时候，其他系统资源也会出现问题(内存，硬盘等)，这些更加影响性能。</p><p>​    一台电脑的服务绝对是比process的数量要多得多，而一个进程的数据处理能力也比一个简单的程序要强大，而且进程会分出许多<strong>子进程</strong>，他们是独立的线程，也会独立的占用CPU资源。</p><blockquote><p>子进程是<strong>父进程的一个拷贝</strong>，子进程获得同父进程相同的数据，但是同父进程使用不同的数据段和堆栈段。 子进程从父进程继承大多数的属性，但是也修改一些属性</p></blockquote><ul><li><h3 id="线程-thread"><a href="#线程-thread" class="headerlink" title="线程(thread)"></a>线程(thread)</h3></li></ul><p>​    一个计算机的进程屈指可数(bushi😋)，但是线程就太多了，一般的进程最多可以开辟出<strong>2048个</strong>线程，因为:</p><blockquote><p>理论上，一个进程可用的虚拟空间是2G，默认情况下，线程的栈大小是1MB，所以理论上是可以有2048个的</p></blockquote><p>当然，一般也用不了创建这么多。</p><p>​    多线程的思想是编程的基本思想，是在应用程序的执行时，由进程程序创建的的，目的是并发运行程序防止堵塞。</p><blockquote><p><strong>个人理解</strong></p><p>就是进程占用的CPU资源非常强大，但是一个一个处理的话会因为一个程序需要较多的time从而拖慢程序运行的节奏，影响程序的性能。所以，就创造了线程，它是一个虚拟的存在，是工程师们设计出来的概念，<strong>线程会交替的执行从而实现并发</strong>。而且，虽然进程之间有物理隔离，但是同一个进程里的线程没有，它们共享调度，内存等，所以通信也更加高效。</p></blockquote><ul><li><h3 id="协程-coroutine"><a href="#协程-coroutine" class="headerlink" title="协程(coroutine)"></a>协程(coroutine)</h3></li></ul><p>​    关于协程是我最开始接触的高并发办法，也是实现高并发的一般手法，在很多的编程语言中(py,c#,js等)，都有**异步(async)**存在的，</p><p>py使用async/await创建coroutine，</p><p>c#使用async/await创建异步，</p><p>js也用async/await创建promise在某些编程语言中(javascript)，一般会通过**回调函数(Callback Functions)<strong>的形式实现，当然现在可以通过</strong>fetch()**实现并发的访问资源，他会返回promise</p><blockquote><p>多线程是一个进程的计算量通过程序的交替执行实现线程去执行，而协程就是一小段一小段的的线程，它不需要在多线程中去切换，内部的资源共享也更容易</p></blockquote><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><h3 id="小刻都能听得懂的总结"><a href="#小刻都能听得懂的总结" class="headerlink" title="小刻都能听得懂的总结"></a>小刻都能听得懂的总结</h3></li></ul><blockquote><p>很简单的总结来说:</p><p>进程(process)就是一个国宾大道，上面的车辆(程序)很多，但是道路就只要那么几条</p><p>线程(thread)就是每辆车子走的路，这个道路是司机(程序员)自己规划的</p><p>协程(coroutine)就是出租车，每个乘客(程序)都只需要进行一小段的线程(所以说协程是轻量级的线程)</p><img src="\img\进程，线程和协程\小刻.jpg" alt="小刻" style="zoom:50%;" /></blockquote><p>​    <font color="red"><strong>所以</strong></font></p><p>​    <font color="red">携程</font>(协程)不是<font color="red">进城</font>(进程)或<font color="red">县城</font>(线程)</p><blockquote><p> 其实cpu的执行能力是很强的，一些超级大的数据也能在一瞬间解决。</p><p>但是，我们还是不够用，还是要设计更多核高性能的cpu，这是因为阻碍处理能力的因数还有很多</p><p>其中，io(input/output)就是重要的一个。。。（坑🤔</p></blockquote><img src="\img\进程，线程和协程\协程是....jpg" alt="协程不是进城或线程" style="zoom:87%;" /><hr><ul><li><h3 id="挂老婆🥵🥵🥵"><a href="#挂老婆🥵🥵🥵" class="headerlink" title="挂老婆🥵🥵🥵"></a>挂老婆🥵🥵🥵</h3></li></ul><p>​    <a href="https://github.com/kifuan"><em>摸鱼佬</em></a>这是我最敬仰的大老之一,非常可爱，它的<a href="https://blog.kifuan.me/">blog</a>的类容也非常硬核，是俺滴好老师。</p><img src="https://avatars.githubusercontent.com/u/61240774?v=4" alt="可可爱爱" style="zoom:150%;" /><p>🤔🤔🤔<strong>来一段A60的名言?</strong></p><img src="\img\进程，线程和协程\A60如是说.jpg" alt="回炉重造" style="zoom:90%;" />]]></content>
    
    
    
    <tags>
      
      <tag>编程思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IT行业的宏观经济学作业</title>
    <link href="/2023/02/01/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    <url>/2023/02/01/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="近年来IT行业势微的经济学原理"><a href="#近年来IT行业势微的经济学原理" class="headerlink" title="近年来IT行业势微的经济学原理"></a>近年来IT行业势微的经济学原理</h1><ol><li>问题的现象，背景与研究<ul><li>为什么IT行业的势微</li><li>产生的背景</li><li>问题的研究</li></ul></li><li>研究的结论与局限性<ul><li>结论</li><li>局限性</li></ul></li></ol><h2 id="现象，背景与讲究"><a href="#现象，背景与讲究" class="headerlink" title="现象，背景与讲究"></a>现象，背景与讲究</h2><h3 id="为什么IT行业的势微"><a href="#为什么IT行业的势微" class="headerlink" title="为什么IT行业的势微"></a>为什么IT行业的势微</h3><p>​    最近一段时间，互联网上一直都有“资本寒冬”，经济下滑，大公司裁员的消息，那么现实到底如何呢。</p><p>​    这是有关部门调查的各行的经济占比图</p><p>​    <img src="\img\task\行业经济占比图.jpg" alt="行业经济占比图" style="zoom:60%;" /></p><p>​    可以看到，对比与传统的房地产，金融或者商贸业等，还是比较占优势，也可以看出目前我国的IT行业还在成长期，数字化和自动化技术还处于成长期，未来应该由比较好的发展光景。但是目前，中国的 IT 行业正面临多重因素的影响，包括市场竞争加剧、技术快速发展、投资环境恶劣等。此外，由于国内经济增长放缓和贸易紧张局势，以及全球经济不确定性加剧，中国 IT 行业也面临着诸多挑战。因此，在未来几年内，中国 IT 行业也可能面临一定的困难和挑战。</p><p>​    但是，越是经济形式不明朗，通过技术研发构建核心竞争力的需求就越发迫切。企业通过高新技术降低成本、提质增效，才是过冬的最佳选择。而且，从目前来看，各个行业目前都必须紧跟IT行业的步伐才能保证在现代化的发展潮流中不掉队，诸如云计算、大数据、物联网、人工智能等近年来耳熟能详的高端技术也慢慢落地，进入我们的日常生活中了。在国家层面上，也一直大力发展高新技术，所以，至少几十年内，IT行业的主导地位还是不可撼动的。</p><h3 id="产生的背景"><a href="#产生的背景" class="headerlink" title="产生的背景"></a>产生的背景</h3><p>​    近些年来，虽然我国的计算机科学在蓬勃发展，但是一般都体现在高新产业，而且现在的市场竞争日益激烈，各大公司都在争夺有限的已经开发了的市场份额。技术的快速发展，新技术的不断涌现，使得许多公司难以保持竞争力。由疫情带来的经济增长放缓，国内经济增长放缓，市场需求下降，对 IT 行业的需求也受到影响。国际上的贸易紧张局势，由于全球贸易紧张局势，中国 IT 行业也受到了一些影响。这些因素的共同作用，导致了IT行业看起来势微</p><h3 id="问题的研究"><a href="#问题的研究" class="headerlink" title="问题的研究"></a>问题的研究</h3><p>​    采取的是在宏观经济学研究中常用的<strong>技术分析法</strong>进行研究的，比如技术趋势分析，分析 IT 行业的核心技术，了解技术发展趋势和未来发展方向。进行市场需求分析，了解市场对 IT 技术的需求，并评估技术的市场潜力。作技术创新分析，评估 IT 行业中的技术创新，了解行业的技术创新动态。调查技术竞争分析，分析 IT 行业的竞争情况，了解行业中的技术差距和竞争力。技术风险分析，评估 IT 行业的技术风险，并对风险进行评估和管理。通过对 IT 行业技术的全面分析，可以了解行业的发展状况，为决策提供支持。</p><hr><h2 id="研究的结论与局限性"><a href="#研究的结论与局限性" class="headerlink" title="研究的结论与局限性"></a>研究的结论与局限性</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>​    2021年7月，Facebook的老板扎克伯格提出了Metaverse战略，计划在五年内把Facebook转型为一家元宇宙公司，宣布投资100亿美元用于研发元宇宙技术，并在10月28日将Facebook更名为Meta。可以说是2021年科技界轰动性的大新闻。资本的嗅觉往往是最灵敏的，欧美和国内股市的巨量资金纷纷涌向与“元宇宙”相关的公司。因此，“元宇宙”一度成为资本市场最火热的概念宠儿。但在此之前，很多人都还不知道什么是“元宇宙”，甚至到了现在，依然有很多人没听过“元宇宙”这个概念!这也为中国IT行业未来的发展带来光亮，中国 IT 行业正处于快速发展阶段，技术发展趋势较为稳定，市场需求旺盛。</p><p>​    我国面对的国际电子信息产业发展的大环境 与20世纪70~80年代有很大的不同，因而加大了产业结构调整和升级的难度。首先，从经济全球化的角度看，这种环境的变化主要体现在：第一，全球经济正处在资源积聚时代（雷达2003年），即产业积聚化、簇群化、国际化，其中包括国际产业纵向关联，横向关联、区位优势形成的产业融合或渗透，以及产业之间建立战略联盟的步伐加快。在这种环境下，IT产业表现的十分突出。IT 行业技术的创新动态较强，但存在部分技术尚未被广泛应用的情况。</p><p>​    我国IT行业经历了近三十年的发展，已经初步具备规模与影响力，初步形成了完整的产业链，其庞大的产业规模与良好的经济效益为带动我国经济的进步做出了巨大的贡献，为我国严峻的就业形势起到了巨大的支撑作用，其意义非同凡响。但IT行业的特点就是技术性强，专业化水平高，而我国虽然拥有庞大的行业规模，但我国IT企业却大多处在组装加工环节，技术水平低，严重缺乏自主的核心技术。同时核心技术作为在华IT企业的命脉，其技术保护性很强。就要在加快外资企业的技术溢出和同时有效的吸收技术溢出。要完善产业结构，强化产业薄弱环节等都是我国IT行业需要研究和解决的问题。</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>​    任何研究都存在局限性，调查也不例外。一些可能的调查局限性。在样本偏差方面，调查样本不能代表整个 IT 行业，结果可能受到样本的偏差影响。调查方法局限性，使用的调查方法有可能不能全面反映 IT 行业的实际情况。时间有所偏差，调查数据可能随着时间的推移而失效，对于 IT 行业的未来发展趋势不具有预测性。资料有局限性，调查所依据的资料有可能不全面，缺乏关键信息。</p><p>​    除此之外， IT 行业发展也存在一些局限性。技术具有风险，IT 行业存在一定的技术风险，如技术失效、安全性问题等，需要加强风险管理。竞争力度加剧， IT 行业竞争激烈，竞争对手不断壮大，需要不断加强技术创新能力。技术更新周期缩短，IT 行业的技术更新周期不断缩短，需要加强技术更新速度。当然也有疫情冲击等等因数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>task</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程思想:鸭子类型</title>
    <link href="/2023/02/01/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/02/01/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="导论——“数据的虚假之天”"><a href="#导论——“数据的虚假之天”" class="headerlink" title="导论——“数据的虚假之天”"></a>导论——“数据的虚假之天”</h1><ol><li>数据类型<ul><li>鸭子类型(duck typing)</li><li>实现举例</li></ul></li><li>数据的本质<ul><li>object组成的world</li></ul></li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>数据类型</strong>是指一种定义在编程语言中的类别，用于表示<strong>变量</strong>、<strong>常量</strong>或<strong>表达式的值</strong>的类型。每种数据类型都有不同的<strong>内存空间限制</strong>，以及支持不同的操作。常见的数据类型包括<strong>整数、浮点数、字符串、布尔值</strong>等。数据类型的选择有助于编译器更好地验证程序的语法和语义正确性，并且可以避免在运行时出现的错误。</p><ul><li><h3 id="鸭子类型-Duck-Typing"><a href="#鸭子类型-Duck-Typing" class="headerlink" title="鸭子类型(Duck Typing)"></a>鸭子类型(Duck Typing)</h3></li></ul><blockquote><p>编程语言是哲学与科学碰撞的产物，有许多基于习惯的设计都有它背后的哲学(わくわく😋)</p><p>听说duck typing是漂亮国🗽的诗人的诗作：</p><blockquote><p><strong>When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.</strong> ——james</p></blockquote><p>大概意思是，当我看到鸟方方面面都像一只鸭子，那么它就是鸭子~~(这不是扯，这叫哲学♂)</p><p>当然也还有很多有意思的思想，比如在错误处理方面的LBYL和EAFP：</p><blockquote><p><strong>Look before you leap.</strong></p></blockquote><blockquote><p><strong>Easier to Ask for Forgiveness than Permission.</strong></p></blockquote><p>就不赘述哒🤗</p></blockquote><ul><li><h3 id="实现举例"><a href="#实现举例" class="headerlink" title="实现举例"></a>实现举例</h3></li></ul><p>这种思想的体现一般是不分编程语言的，在实现某些功能后就可以使用(比如<strong>oop</strong>)</p><p>例えば：</p><p>在python里，有一种数据类型叫<strong>Dict</strong>，它是一种<strong>无序的，可变的数据集合类型，数据是以key:value的形式存储的</strong></p><blockquote><p><strong>我们可以用dict[key]取出它的value值</strong></p></blockquote><p>当你用python里的_<em>dir</em>_()查看类型实现时，会发现它实现了许多方法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">d = <span class="hljs-built_in">dict</span>()<br><span class="hljs-built_in">print</span>(d.__dir__())<br><span class="hljs-comment"># [&#x27;__new__&#x27;, &#x27;__repr__&#x27;, &#x27;__hash__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__lt__&#x27;, &#x27;__le__&#x27;, &#x27;__eq__&#x27;, &#x27;__ne__&#x27;, &#x27;__gt__&#x27;, &#x27;__ge__&#x27;, &#x27;__iter__&#x27;, &#x27;__init__&#x27;, &#x27;__or__&#x27;, &#x27;__ror__&#x27;, &#x27;__ior__&#x27;, &#x27;__len__&#x27;, &#x27;__getitem__&#x27;, &#x27;__setitem__&#x27;, &#x27;__delitem__&#x27;, &#x27;__contains__&#x27;, &#x27;__sizeof__&#x27;, &#x27;get&#x27;, &#x27;setdefault&#x27;, &#x27;pop&#x27;, &#x27;popitem&#x27;, &#x27;keys&#x27;, &#x27;items&#x27;, &#x27;values&#x27;, &#x27;update&#x27;, &#x27;fromkeys&#x27;, &#x27;clear&#x27;, &#x27;copy&#x27;, &#x27;__reversed__&#x27;, &#x27;__class_getitem__&#x27;, &#x27;__doc__&#x27;, &#x27;__str__&#x27;, &#x27;__setattr__&#x27;, &#x27;__delattr__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__reduce__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__format__&#x27;, &#x27;__dir__&#x27;, &#x27;__class__&#x27;]</span><br></code></pre></td></tr></table></figure><p>当然，这些都是c实现的，我们暂时不管，我们看到一个显眼的**_<em>dict</em>_**的魔术方法，用法是:</p><blockquote><p>以key:value的形式，存放属性：输入值</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">My_Dict</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        self.args = args<br>        self.kwargs = kwargs<br>        <br>md = My_Dict(<span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>)<br><span class="hljs-built_in">print</span>(md.__dict__)<br><span class="hljs-comment"># 返回字典，它是以类属性为dict，类内容是&#123;&#x27;args&#x27;: (&#x27;value1&#x27;, &#x27;value2&#x27;), &#x27;kwargs&#x27;: &#123;&#125;&#125;</span><br><span class="hljs-built_in">print</span>(md.__dict__[<span class="hljs-string">&#x27;args&#x27;</span>])<br><span class="hljs-comment"># 返回*args的数据:(&#x27;value1&#x27;,&#x27;value2&#x27;)</span><br></code></pre></td></tr></table></figure><p>所以，我们就可以把它看作dict[key]取属性的字典</p><blockquote><p><strong>看山便是山，看水亦是水</strong></p><p><strong>能吃就是饭，能烧就是柴</strong></p></blockquote><p>这使我们更关注对象的行为，而不是类型</p><hr><p>在java中也有体现，也就是接口(<strong>interface</strong>)实现，通过implements对interface进行实现，就可以得到所用方法实现的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">duck</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">quacks</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">yellow</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">duck</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quacks</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;yellow duck&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">black</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">duck</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quacks</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;black duck&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">cry</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">yellow</span>();<br>        y.quacks();<br>        <br>        <span class="hljs-type">cry</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">black</span>();<br>        b.quacks();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>提供接口(interface)可以让实现它的class得到它定义的操作，也就是是只要实现了duck这个接口，他就在**<del>鸭子叫</del>**</p><hr><h2 id="数据的本质"><a href="#数据的本质" class="headerlink" title="数据的本质"></a>数据的本质</h2><p>数据的本质其实就是一个个对象，而对象又是实现了某些方法的实例</p><p>比如包括：</p><blockquote><p>基本数据类型：’byte’,’short’,’int’,’long’,’float’,’double’,’boolean’和’char’</p><p>引用数据类型：class，implement，array等</p></blockquote><p>当然概念在各大编程语言通用，但是基本类型可能有偏差</p><ul><li><h3 id="object组成的world"><a href="#object组成的world" class="headerlink" title="object组成的world"></a>object组成的world</h3></li></ul><blockquote><p>duck类型就是在说，任何数据类型都是假的，都只是实现某些api的类的实例，也就是对象(object)</p><p>这种实现，在py里通过魔术方法，在java或者go中，通过接口(implement)，结构体(struct)</p></blockquote><p>结论：</p><p><strong>也就是说程序运行的时候不看你有什么数据结构，只看你是否实现了某些对应的方法| 接口 | 结构体</strong></p><p>**<del>数据类型根本就不存在(癫狂</del>**🥵👈🤣</p>]]></content>
    
    
    
    <tags>
      
      <tag>编程思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-二，网络的协议</title>
    <link href="/2023/01/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%8C%EF%BC%8C%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/01/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BA%8C%EF%BC%8C%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<ol><li>由协议组成的world<ul><li>iso七层模型</li><li>简化版四层概念模型</li></ul></li><li>网络的流程<ul><li>如何通信</li><li>如何访问</li><li>如何创造</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络:一，计算机网络的组成</title>
    <link href="/2023/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%80%EF%BC%8C%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%84%E6%88%90/"/>
    <url>/2023/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%80%EF%BC%8C%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="导论——范围网络"><a href="#导论——范围网络" class="headerlink" title="导论——范围网络"></a>导论——范围网络</h1><ol><li>由网络组成的world<ul><li>局域网(LAN)的概念与组成</li><li>广域网(WAN)的概念与组成</li><li>互联网(INTERNET)的概念与组成</li></ul></li></ol><h2 id="1-由网络组成的world"><a href="#1-由网络组成的world" class="headerlink" title="1. 由网络组成的world"></a>1. 由网络组成的world</h2><blockquote><h3 id="局域网-LAN-的概念与组成"><a href="#局域网-LAN-的概念与组成" class="headerlink" title="局域网(LAN)的概念与组成"></a>局域网(LAN)的概念与组成</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>局域网(LAN)<strong>是:局部地区形成的一个</strong>区域网络</strong>，其自身相对其他网络传输速度更快，性能更稳定，框架更简易，而且这是封闭性的。但是局域网会有一个与外界网络的<strong>接入点</strong>（<em>比如路由器的WAN口</em>，接入的设备(路由器)主要负责中继无线计算机(网络设备)之间的数据包传输和分配，还负责中继无线计算机(网络设备)和internet之间的数据包）来作为交换机等处理数据。无线局域网(WLAN)有一个通信标准——<strong>IEEE 802.11</strong>,<strong>Wi-Fi</strong>就是对这一标准最好的实现。<del>要长脑子了😋</del></p><p>（<font color="red"><strong>路由器和交换机并不是一个概念，路由器在网络层，路由器会分配子网的IP地址并根据IP地址寻址，还可以处理TCP/IP协议，交换机不可以。交换机在中继层，它根据MAC地址寻址，用来分配网络数据，也就是要用LAN口物理链接</strong></font>）<strong>但是现在家用路由器一般都集成了交换机的功能</strong></p><img src="\img\计算机网络-iso模型和计算机的理解\局域网原理.jpg" alt="局域网原理" style="zoom:67%;" /><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>局域网的基本组成是硬件系统和软件系统(<del>网上查的，俺真厉害😊👈🤣</del>)</p><blockquote><p>硬件系统</p><p><strong>网络服务器、网络工作站、链接设备(网卡)以及传输介质和其他互连设备</strong></p><p><em>网络服务器</em>：种类很多，分为文件服务器，打印服务器，硬件服务器等等。当然这些也都是非必要的。</p><p><em>网络工作站</em>：也就是客户端(client)，一般就是电脑计算机哒💻。可以通过软件等访问网络服务器进行操作。</p><p><em>连接设备</em>：即是网卡，简称”NIC“，它是链接计算机与网络的硬件的设备(种类非常多😵)。</p><p>传输介质：就像空气是声音传播的介质一样，上述的设备通信和数据传输都需要介质，一般的传输介质是<strong>双绞线，同轴电缆，光纤等</strong>。</p><p>其他…🤗🤗🤗</p><p>软件系统</p><p><strong>主要包括网络操作系统，网络数据库管理系统，网络应用软件</strong></p><p><em>网络操作系统</em>：说是一种能代替操作系统的软件程序，借用网络互相传递数据和各种信息，分为服务端(server)和客户端(client)。</p><p><em>网络数据库管理系统</em>：是一种能将内存里的数据存入硬盘做数据持久化的软件，简称<strong>DBMS</strong>。他的目地是管理和控制数据库，以保证数据库的安全性和完整性。</p><p><em>网络应用软件</em>：就是日常使用的app捏😋😋😋</p></blockquote><img src="\img\计算机网络-iso模型和计算机的理解\标准局域网.jpg" alt="标准局域网" style="zoom:67%;" /><p><del>在个人设备localhost(127.0.0.1)网段下的进程不被外界打扰，也像是一个小型的LAN</del></p></blockquote><hr><blockquote><h4 id="广域网-WAN-的概念与组成"><a href="#广域网-WAN-的概念与组成" class="headerlink" title="广域网(WAN)的概念与组成"></a>广域网(WAN)的概念与组成</h4><p><strong>概念</strong></p><p>**广域网(WAN)**是一种大型的，地域型的计算机网络集合，但其范围可以超过城市，国家乃至全球。所以，广域网其实一种相对概念。(<s><del>局域网上的局域网🤗</del></s>)</p><p><strong>组成</strong></p><p>一般由<strong>主机(资源子网)和通信子网</strong>组成</p><blockquote><p>*主机(资源子网)*：由上网的所有<strong>主机</strong>及其<strong>外部设备</strong>组成😵‍💫😵‍💫😵‍💫。</p><p><em>通信子网</em>：由一些专用的通信处理器(即<strong>节点交换机</strong>)及其运行的<strong>软件，集中器</strong>等设备和链接这些节点的<strong>通信链路</strong>组成。</p></blockquote><img src="\img\计算机网络-iso模型和计算机的理解\广域网.jpg" alt="广域网" style="zoom:67%;" /></blockquote><hr><blockquote><h4 id="互联网-INTERNET-的概念与组成"><a href="#互联网-INTERNET-的概念与组成" class="headerlink" title="互联网(INTERNET)的概念与组成"></a>互联网(INTERNET)的概念与组成</h4><p><strong>概念</strong></p><p>**互联网(INTERNET)**是由局域网，广域网等组成的一个最大网络，它是一种宽泛的概念型的存在。</p><p><strong>组成</strong></p><p>按照工作方式分为<strong>边缘部分和核心部分</strong></p><blockquote><p><em>边缘部分</em>：就是连接在互联网上的所有主机(又称**”端系统”**)，是用户直接使用的。💻📱</p><p><em>核心部分</em>：是由大量网络和连接这些网络的路由器组成，其为边缘部分提供服务。</p></blockquote><img src="\img\计算机网络-iso模型和计算机的理解\INTERNET.png" alt="INTERNET" style="zoom:67%;" /></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QQbot第一弹:nonebot的原理————go-cqhttp的数据包</title>
    <link href="/2023/01/11/QQbot%E7%AC%AC%E4%B8%80%E5%BC%B9-nonebot%E7%9A%84%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94gocqhttp%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/"/>
    <url>/2023/01/11/QQbot%E7%AC%AC%E4%B8%80%E5%BC%B9-nonebot%E7%9A%84%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94gocqhttp%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><ol><li>go-cqhttp的链接<ul><li>项目的概述</li></ul></li><li>go-cqhttp与nonebot的通信连接<ul><li>连接方式</li><li>socket服务器的接收实例</li><li>websocket服务器的接收实例</li></ul></li></ol><blockquote><h3 id="go-cqhttp的链接"><a href="#go-cqhttp的链接" class="headerlink" title="go-cqhttp的链接"></a>go-cqhttp的链接</h3><ul><li><h4 id="项目的概述"><a href="#项目的概述" class="headerlink" title="项目的概述"></a>项目的概述</h4></li></ul><p><b><a href="https://docs.go-cqhttp.org/">go-cqhttp</a></b>,基于 Mirai 以及 MiraiGo 的 OneBot Golang 原生实现的项目，主力是go语言编写(<font color=red><s>俺也不会捏</s></font>🤗)</p></blockquote><p>(反正就是ddl很nb哒←<font size="2" color="cyan">明明什么都不知道的小白</font>👈😂)</p><blockquote><p>它的兼容性:</p><div id="interface"><font size="4" color="black"><b>接口</b></font></div><ul><li><p>http api</p></li><li><p>反向http post</p></li><li><p>正向websocket</p></li><li><p>反向websocket</p></li></ul><p><font size="4" color="black"><b>性能</b></font></p><ul><li>在关闭数据库的情况下, 加载 25 个好友 128 个群运行 24 小时后内存使用为 10MB 左右. 开启数据库后内存使用将根据消息量增加 10-20MB , 如果系统内存小于 128M 建议关闭数据库使用。<br><a href="https://docs.go-cqhttp.org/">go-cqhttp 帮助中心</a></li></ul><p><img src="https://user-images.githubusercontent.com/25968335/120111974-8abef880-c139-11eb-99cd-fa928348b198.png" alt="go-cqhttp"></p></blockquote><hr><h2 id="go-cqhttp与nonebot的通信连接"><a href="#go-cqhttp与nonebot的通信连接" class="headerlink" title="go-cqhttp与nonebot的通信连接"></a>go-cqhttp与nonebot的通信连接</h2><ul><li><h4 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h4></li></ul><p>go-cqhttp与nonebot的链接可以选择gc提供的<a href="#interface">接口</a>的几种方式</p><img src="\img\QQbot第一弹-nonebot的原理——gocqhttp的数据包\interface.png" alt="interface" style="zoom:60%;" /><p>我想要反向websocket进行获取，就是我作websoocket的服务器，让go-cqhttp作客户端给我们发送消息<font color="red"><s>(其实是因为不是很了解这些接口)</s></font>，我好菜😭😭😭</p><img src="\img\QQbot第一弹-nonebot的原理——gocqhttp的数据包\choose.png" alt="choose" style="zoom:60%;" /><p>选择3，反向websocket，这样也可以看看go-cqhttp的到底发的什么玩意😋😋😋</p><ul><li><h4 id="socket服务器的简单实例"><a href="#socket服务器的简单实例" class="headerlink" title="socket服务器的简单实例"></a>socket服务器的简单实例</h4></li></ul><p>我们先打开go-cqhttp并登录</p><img src="\img\QQbot第一弹-nonebot的原理——gocqhttp的数据包\gocq_login.png" alt="gocq_login" style="zoom:50%;" /><p>下面是一个简单的socket服务器，那么为什么要用socket而不是websocket捏，因为<s>我搞错了&gt; 😋</s>，因为我也想知道如果协议不对，go-cqhttp会发个什么东西过来😊😊😊</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br>server = socket.socket(socket.AF_INET, socket.sock_STREAM)<br>server.bind((<span class="hljs-string">&quot;&quot;</span>, post)) <span class="hljs-comment"># 端口号</span><br>server.listen(<span class="hljs-number">126</span>) <span class="hljs-comment"># 设置监听，参数为最大队列数</span><br>new_socket, path = server.sccept()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    data = new_socket.recv()<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) != <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(data.decode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br>    <span class="hljs-keyword">else</span>:<br>        new_socket.close()<br>        <span class="hljs-keyword">break</span><br>server.close()<br></code></pre></td></tr></table></figure><p>↑(<font color="blue"><s>什么垃圾code</s></font>😭😭😭)</p><p>运行之后,出现一次心跳包后就close了，说明go-cqhttp客户端发现协议不对，主动断开链接了:</p><img src="\img\QQbot第一弹-nonebot的原理——gocqhttp的数据包\gocq_warning.png" alt="gocq_warning" style="zoom:60%;" /><p>显示<font color="red"><b>unexpected EOF</b></font>,至于是什么意思。。。（自行baidu😊👈😂）</p><p>我们看看python的socket服务端，它为我们提供了更详细的内容:</p><img src="\img\QQbot第一弹-nonebot的原理——gocqhttp的数据包\gocq_py.png" alt="gocq_py" style="zoom:60%;" /><p>发现<font color="red"><b>Connection: Upgrade</b></font>和<font color="red"><b>Upgrade: websocket</b></font>，意思就是说要更换成<b>websocket</b></p><p><b>好！那就换吧</b>🤗🤗🤗</p><hr><ul><li><h4 id="websocket服务器的接收实例"><a href="#websocket服务器的接收实例" class="headerlink" title="websocket服务器的接收实例"></a>websocket服务器的接收实例</h4></li></ul><p>我使用python写了一个简单的异步websocket服务器，用json来解析json数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> websocket<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">data</span>(<span class="hljs-params">websocket, path</span>): <span class="hljs-comment">#创建一个异步回调函数data，传入两个参数，websocket套接字，path数据协议</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> message <span class="hljs-keyword">in</span> websocket: <span class="hljs-comment"># 迭代出websocket里面的数据</span><br>        j = json.loads(message)<br>        <span class="hljs-built_in">print</span>(j)<br>asyncio.get_event_loop().run_until_compete(websocket.server(data, <span class="hljs-string">&quot;localhost&quot;</span>, post)) <span class="hljs-comment"># 传入post，host，和</span><br>asyncio.get_event_loop().run_forever()<br></code></pre></td></tr></table></figure><blockquote><p>我们通过异步的方式接收代码，得到的数据可以分为三种</p><blockquote><p>连接成功的提示消息：(成功时会发出消息”<strong>meta_event_type”为”lifecycle</strong>“)</p><img src="\img\QQbot第一弹-nonebot的原理——gocqhttp的数据包\success.png" alt="success" style="zoom:60%;" /><p>与客户端的<u>心跳</u><s>❤️</s>包:  (心跳包的”<strong>post_type”是”meta_event</strong>“)</p><img src="\img\QQbot第一弹-nonebot的原理——gocqhttp的数据包\mete_event.png" alt="mete_event" style="zoom:60%;" /><p>对应的消息数据：(news_event的**”post_type”是”message”**)</p><img src="\img\QQbot第一弹-nonebot的原理——gocqhttp的数据包\message_data.png" alt="message_data" style="zoom:60%;" /></blockquote><p>这其中的就包括相应的<b>消息数据</b>，<b>time</b>等等👈😊，也就是有了nb的第一版(bushi</p></blockquote><p>最后，挂一张老婆  <a href="https://github.com/Ikaros-521"><strong>Love丶伊卡洛斯</strong></a>(java大佬，<a href="https://space.bilibili.com/3709626">b站up</a>，<s><font color="red"><b>大厂员工(不干了)</b></font></s>)：</p><p><img src="https://avatars.githubusercontent.com/u/40910637?v=4" alt="**Love丶伊卡洛斯**"></p>]]></content>
    
    
    
    <tags>
      
      <tag>nonebot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇:hello world!</title>
    <link href="/2023/01/11/%E7%AC%AC%E4%B8%80%E7%AF%87-hello-world/"/>
    <url>/2023/01/11/%E7%AC%AC%E4%B8%80%E7%AF%87-hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇写的目的其实就是说明，俺要开始写了，所以是hallo-world"><a href="#第一篇写的目的其实就是说明，俺要开始写了，所以是hallo-world" class="headerlink" title="第一篇写的目的其实就是说明，俺要开始写了，所以是hallo world!"></a>第一篇写的目的其实就是说明，俺要开始写了，所以是<font color="red">hallo world</font>!</h1><blockquote><p>我以后会用test这个tag来收集md编写技巧或者一些什么东西,也可以不用看吧🤗🤗🤗</p></blockquote><h2 id="留下点东西吧"><a href="#留下点东西吧" class="headerlink" title="留下点东西吧"></a>留下点东西吧</h2><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello world!&quot;</span>)<br></code></pre></td></tr></table></figure><p>javascript</p></blockquote><blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello world!&quot;</span>)<br></code></pre></td></tr></table></figure><p>python</p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">helloworld</span>&#123;  <span class="hljs-comment">//public类名要与java文件名一致,也就是文件的出口</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(string[] args)</span>&#123;<br>       System.out.print(<span class="hljs-string">&quot;hello world!&quot;</span>); <span class="hljs-comment">//有System.out当然有System.in哒😊</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>java</p></blockquote><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   fmt.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>go</p></blockquote><blockquote><blockquote><p>最后,贴一张我的偶像<a href="https://github.com/djkcyl">A60</a>🥵🥵🥵,是我暂时的信仰捏😋😋😋</p></blockquote><p><img src="https://avatars.githubusercontent.com/u/59153990?v=4" alt="A60"></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
